# -*- coding: utf-8 -*-
"""geography.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n73YhSgEkg8sz2EZWH9eGF089z7D7K9q
"""

# 1: Import Library
import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Polygon
from sklearn.cluster import DBSCAN, KMeans
from sklearn.feature_extraction.text import TfidfVectorizer
from bokeh.io import output_file, save
from bokeh.plotting import figure
from bokeh.models import GeoJSONDataSource, WMTSTileSource
from bokeh.palettes import Category20
from bokeh.transform import factor_cmap
import os

#2: Read Data
gpkg_path = r'E:/uom2/apply/downloaded_data/downloaded_data_polygons.gpkg'
excel_path = r'E:/uom2/apply/downloaded_data/survey_responses.xlsx'

gdf = gpd.read_file(gpkg_path)
survey_df = pd.read_excel(excel_path)

gdf = gdf.merge(survey_df, on="id", how="left").drop(columns=["Category"])
gdf = gdf.to_crs(epsg=3857)
gdf = gdf[gdf.geometry.notnull()].copy()
print(f"✅ Loaded {len(gdf)} records, valid: {gdf.geometry.is_valid.sum()}, invalid: {(~gdf.geometry.is_valid).sum()}")

# 3: NLP Clustering
gdf['comment'] = gdf['comment'].fillna('')
vectorizer = TfidfVectorizer(stop_words='english')
X = vectorizer.fit_transform(gdf['comment'])

kmeans = KMeans(n_clusters=9, random_state=0)
gdf['theme_cluster'] = kmeans.fit_predict(X)

gdf['theme_name'] = gdf['theme_cluster'].apply(lambda x: f"Theme {x}")

# 4: Spatial Clustering
gdf['centroid'] = gdf.geometry.centroid
gdf['x'] = gdf.centroid.x
gdf['y'] = gdf.centroid.y

new_place_groups = {}

for theme, sub_df in gdf.groupby('theme_name'):
    coords = sub_df[['x', 'y']].to_numpy()
    db = DBSCAN(eps=50, min_samples=2)
    labels = db.fit_predict(coords)

    prefix = "T" + theme.split()[-1]  # Theme 0 -> T0
    group_counter = {}
    for idx, label in zip(sub_df.index, labels):
        if label == -1:
            # 孤立点
            label_name = "O0"
        else:
            if label not in group_counter:
                group_counter[label] = len(group_counter)
            label_name = f"F{group_counter[label]}"

        new_place_groups[idx] = f"{prefix}_{label_name}"

gdf['place_group'] = gdf.index.map(new_place_groups)

#5: Wrong Flag
def compute_wrong_flags(df_group):
    geometries = df_group.geometry.values
    flags = [False] * len(df_group)
    for i in range(len(df_group)):
        for j in range(i + 1, len(df_group)):
            c_dist = geometries[i].centroid.distance(geometries[j].centroid)
            a_diff = abs(geometries[i].area - geometries[j].area) / max(geometries[i].area, geometries[j].area)
            if c_dist < 20 and a_diff > 0.3:
                flags[i] = True
                flags[j] = True
    return flags

gdf_valid = gdf[gdf.geometry.notnull()].copy()
wrong_flags_all = []

for group in gdf_valid['place_group'].dropna().unique():
    df_group = gdf_valid[gdf_valid['place_group'] == group]
    wrong_flags = compute_wrong_flags(df_group)
    wrong_flags_all.extend(wrong_flags)

gdf_valid['wrong'] = wrong_flags_all if len(wrong_flags_all) == len(gdf_valid) else False
gdf = gdf.drop(columns=['wrong'], errors='ignore').merge(gdf_valid[['id', 'wrong']], on='id', how='left')

# 6: Save GPKG and Excel

gdf_final = gdf[['theme_name', 'place_group', 'comment', 'wrong', 'geometry']].copy()
output_gpkg = r"E:/uom2/apply/downloaded_data/output_geography_grouped.gpkg"
gdf_final.rename(columns={'theme_name': 'theme'}).to_file(output_gpkg, driver="GPKG")
print(f"GPKG saved at: {output_gpkg}")


df_export = gdf[['theme_name', 'place_group', 'comment', 'wrong']].rename(columns={'theme_name': 'theme'})
df_export = df_export.sort_values(by=['theme', 'place_group'])
def beautify_group_display(df, group_cols):
    df = df.copy()
    last_values = {col: None for col in group_cols}
    for i, row in df.iterrows():
        for col in group_cols:
            if row[col] == last_values[col]:
                df.at[i, col] = ''
            else:
                last_values[col] = row[col]
    return df

group_cols = ['theme', 'place_group']
df_beautified = beautify_group_display(df_export, group_cols)

beautified_excel_path = r"E:/uom2/apply/downloaded_data/output_geography_grouped.xlsx"
df_beautified.to_excel(beautified_excel_path, index=False)
print(f" Excel saved at: {beautified_excel_path}")

#7: Plot Map
from bokeh.io import output_notebook, show
from bokeh.plotting import figure
from bokeh.models import GeoJSONDataSource, WMTSTileSource
from bokeh.palettes import Category20
from bokeh.transform import factor_cmap
import json

# Set up Bokeh output
output_notebook()

# Convert GeoDataFrame to GeoJSON
gdf_plot = gdf_final.to_crs(epsg=3857)
geo_source = GeoJSONDataSource(geojson=gdf_plot.to_json())

# Create figure
p = figure(
    title="Geo Design Geography Group - EPSG:3857",
    width=800,
    height=600,
    x_axis_type="mercator",
    y_axis_type="mercator",
    tools="pan,wheel_zoom,reset,save"
)

# Add basemap (OpenStreetMap)
tile_provider = WMTSTileSource(
    url="https://tile.openstreetmap.org/{Z}/{X}/{Y}.png"
)
p.add_tile(tile_provider)

# Create a color map based on 'place_group'
unique_groups = gdf_plot['place_group'].unique().tolist()
palette = Category20[20] if len(unique_groups) <= 20 else Category20[20] * (len(unique_groups) // 20 + 1)

p.patches(
    'xs', 'ys',
    source=geo_source,
    fill_alpha=0.6,
    line_color='black',
    line_width=0.5,
    fill_color=factor_cmap('place_group', palette=palette, factors=unique_groups)
)

# Show plot
show(p)

